[{"categories":["前端"],"content":"node js 常见问题（mac版本）","date":"2022-11-20","objectID":"/nodejs-qa/","tags":["nodejs"],"title":"macOS 降低node版本","uri":"/nodejs-qa/"},{"categories":["前端"],"content":"降低版本 目前安装的最新版本V18.10.0，以前的老项目运行报错，无法启动。 我的node 是用homebrew安装的，所以，网上使用n 切换 node 版本无效。 解决方案 卸载 brew uninstall node@18 安装14版本 brew install node@14 link 如果不做这一步，node -v 会提示找不到node命令 brew link node@14 执行命令会报错 Error: Could not symlink bin/npm Target /opt/homebrew/bin/npm already exists. You may want to remove it: rm '/opt/homebrew/bin/npm' To force the link and overwrite all conflicting files: brew link --overwrite node@14 To list all files that would be deleted: brew link --overwrite --dry-run node@14 解决方法就是 强制覆盖，照着命令提示操作，是不是很方便 brew link --overwrite node@14 ","date":"2022-11-20","objectID":"/nodejs-qa/:1:0","tags":["nodejs"],"title":"macOS 降低node版本","uri":"/nodejs-qa/"},{"categories":["MySQL"],"content":"好记性不如烂笔头","date":"2022-11-13","objectID":"/qa/","tags":["MySQL"],"title":"MySQL常见问题整理","uri":"/qa/"},{"categories":["MySQL"],"content":"无法重启 报错信息 2022-11-13T11:27:13.455198Z 0 [Warning] [MY-000081] [Server] option 'max_allowed_packet': unsigned value 107374182400 adjusted to 1073741824. 2022-11-13T11:27:13.455277Z 0 [Warning] [MY-010915] [Server] 'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and 'ERROR_FOR_DIVISION_BY_ZERO' sql modes should be used with strict mode. They will be merged with strict mode in a future release. 2022-11-13T11:27:13.455373Z 0 [System] [MY-010116] [Server] /www/server/mysql/bin/mysqld (mysqld 8.0.24) starting as process 27708 2022-11-13T11:27:13.518045Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2022-11-13T11:28:39.973579Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. InnoDB: Progress in percents: 12022-11-13T11:28:40.484074Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: '::' port: 33060, socket: /tmp/mysqlx.sock 2022-11-13T11:28:40.837360Z 0 [System] [MY-010229] [Server] Starting XA crash recovery... 2022-11-13T11:28:40.850611Z 0 [System] [MY-010232] [Server] XA crash recovery finished. 2022-11-13T11:28:41.101314Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2022-11-13T11:28:41.101688Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. 2022-11-13T11:28:41.127441Z 0 [System] [MY-010931] [Server] [root@ecs-733a home]# ps -ef|grep mysql root 11456 1 0 1月19 ? 00:00:00 /bin/sh /www/server/mysql/bin/mysqld_safe --datadir=/www/server/data --pid-file=/www/server/data/ecs-733a.pid root 26896 19969 0 19:26 pts/0 00:00:00 grep --color=auto mysql mysql 27114 11456 40 7月20 ? 47-06:58:41 /www/server/mysql/bin/mysqld --basedir=/www/server/mysql --datadir=/www/server/data --plugin-dir=/www/server/mysql/lib/plugin --user=mysql --log-error=ecs-733a.err --open-files-limit=65535 --pid-file=/www/server/data/ecs-733a.pid --socket=/tmp/mysql.sock --port=63306 分析 刚开始以为是数据量太大无法启动，其中一张历史表数据两千万左右的采集数据,实际上不是 解决 将 11456 与 27114 kill 重启，正常启动 ","date":"2022-11-13","objectID":"/qa/:1:0","tags":["MySQL"],"title":"MySQL常见问题整理","uri":"/qa/"},{"categories":["MySQL"],"content":"更新大批量数据 提示Lock wait timeout exceeded; try restarting transaction 等待时间超时导致。 有时候看看show engine innodb status , 并结合 show full processlist;能暂时解决问题；但一直不能精确定位； 在5.5中，information_schema库中增加了三个关于锁的表（MEMORY引擎）； innodb_trx ## 当前运行的所有事务 innodb_locks ## 当前出现的锁 innodb_lock_waits ## 锁等待的对应关系 数据库配置文件修改： 原因：原因是你使用的InnoDB 表类型的时候, 默认参数:innodb_lock_wait_timeout设置锁等待的时间是50s, 因为有的锁等待超过了这个时间,所以抱错. 你可以把这个时间加长,或者优化存储过程,事务避免过长时间的等待. 解决的办法有两个： 第一：innodb_lock_wait_timeout 锁定等待时间改大 my.ini文件： #innodb_lock_wait_timeout = 50 修改为 innodb_lock_wait_timeout = 500 ","date":"2022-11-13","objectID":"/qa/:2:0","tags":["MySQL"],"title":"MySQL常见问题整理","uri":"/qa/"},{"categories":["macOS"],"content":"Excel很强大，用好了事半功倍","date":"2022-11-07","objectID":"/royaltsx/","tags":["macOS","tools"],"title":"Mac上目前为止用过的最好用的SSH工具RoyalTSX工具","uri":"/royaltsx/"},{"categories":["macOS"],"content":" 这是目前为止，满足我所有需求的一款SSH工具。 官网地址 官网地址 常规使用教程 ","date":"2022-11-07","objectID":"/royaltsx/:0:0","tags":["macOS","tools"],"title":"Mac上目前为止用过的最好用的SSH工具RoyalTSX工具","uri":"/royaltsx/"},{"categories":["office"],"content":"Excel很强大，用好了事半功倍","date":"2022-11-07","objectID":"/%E5%B8%B8%E7%94%A8excel%E5%85%AC%E5%BC%8F/","tags":["office","excel"],"title":"常用Excel公式整理","uri":"/%E5%B8%B8%E7%94%A8excel%E5%85%AC%E5%BC%8F/"},{"categories":["office"],"content":" 找出两列中在A列存在B列中不存在的数据 =IF(COUNTIF(A:A,B563)\u003e0,\"A列有\",\"A列没有\") 效果如下 操作时，在C1中写下上面的公式，然后用鼠标选中C1单元格的右下角，拖到要检测的数据底部即可。 ","date":"2022-11-07","objectID":"/%E5%B8%B8%E7%94%A8excel%E5%85%AC%E5%BC%8F/:0:0","tags":["office","excel"],"title":"常用Excel公式整理","uri":"/%E5%B8%B8%E7%94%A8excel%E5%85%AC%E5%BC%8F/"},{"categories":["sol"],"content":"一个小坑，如果到生产环境，就是事故","date":"2022-11-04","objectID":"/mybatis%E4%B8%ADint%E7%B1%BB%E5%9E%8B%E5%88%A4%E7%A9%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/","tags":["MyBatis","Java"],"title":"设备状态更新失败，原来是这个坑导致的","uri":"/mybatis%E4%B8%ADint%E7%B1%BB%E5%9E%8B%E5%88%A4%E7%A9%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"},{"categories":["sol"],"content":"项目中，设备基础信息中有个状态字段，类型是int型。由于设备信息是从别的平台上同步过来的，这个状态也需要同步。 为了保证状态的准确性，每次更新我都会根据是否在一定的时间范围内有采集数据，如果有，就认为是在线，如果没有，就更新成离线。 原本的更新就两个三个字段，状态、更新人、更新时间。今天看代码发现还需要更新最新的指标，就把Mybatis中的更新sql给扩展一下，一改出问题了 \u003cif test=\"item.status != null and item.status != ''\"\u003e status = #{item.status}, \u003c/if\u003e and后面的半段就是坑所在的位置。设备状态0代表正常，如果传0进行更新，and后面的代码会认为当前的status是‘’，不会进入更新逻辑。我写的是批量更新，造成的后果可想而知。 解决方案 \u003cif test=\"item.status != null\"\u003e status = #{item.status}, \u003c/if\u003e ","date":"2022-11-04","objectID":"/mybatis%E4%B8%ADint%E7%B1%BB%E5%9E%8B%E5%88%A4%E7%A9%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/:0:0","tags":["MyBatis","Java"],"title":"设备状态更新失败，原来是这个坑导致的","uri":"/mybatis%E4%B8%ADint%E7%B1%BB%E5%9E%8B%E5%88%A4%E7%A9%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"},{"categories":["sol"],"content":"项目问题总结","date":"2022-11-03","objectID":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/","tags":["SpringBoot"],"title":"“一个swraggerui的类型转换的错误\"","uri":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/"},{"categories":["sol"],"content":"项目中用到了springfox-swagger-ui这个api框架，集成后项目启动没有问题，接口也能正常访问，但是页面一刷新就会报下面的这个错误： 2022-11-03 14:32:54-[WARN]--io.swagger.models.parameters.AbstractSerializableParameter-getExample-421- Illegal DefaultValue null for parameter type integer java.lang.NumberFormatException: For input string: \"\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.valueOf(Long.java:803) at io.swagger.models.parameters.AbstractSerializableParameter.getExample(AbstractSerializableParameter.java:412) at sun.reflect.GeneratedMethodAccessor460.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:689) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:755) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serializeContents(IndexedListSerializer.java:119) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:79) at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:18) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:728) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:755) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:728) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:755) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178) at com.fasterxml.jackson.databind.ser.std.MapSerializer.serializeFields(MapSerializer.java:726) at com.fasterxml.jackson.databind.ser.std.MapSerializer.serializeWithoutTypeInfo(MapSerializer.java:681) at com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:637) at com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:33) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:728) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:755) at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:319) at com.fasterxml.jackson.databind.ObjectMapper._writeValueAndClose(ObjectMapper.java:4409) at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3663) at springfox.documentation.spring.web.json.JsonSerializer.toJson(JsonSerializer.java:38) at springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(Swagger2Controller.java:105) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.","date":"2022-11-03","objectID":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/:0:0","tags":["SpringBoot"],"title":"“一个swraggerui的类型转换的错误\"","uri":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/"},{"categories":["sol"],"content":"方法1 实体类中，给Integer类型的属性加注解时，要给example赋值 项目中有很多实体类了，如果要改，就得每个都改。 ","date":"2022-11-03","objectID":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/:1:0","tags":["SpringBoot"],"title":"“一个swraggerui的类型转换的错误\"","uri":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/"},{"categories":["sol"],"content":"方法2 在项目pom.xml中增加两个依赖 \u003cdependency\u003e \u003cgroupId\u003eio.swagger\u003c/groupId\u003e \u003cartifactId\u003eswagger-annotations\u003c/artifactId\u003e \u003cversion\u003e1.5.22\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.swagger\u003c/groupId\u003e \u003cartifactId\u003eswagger-models\u003c/artifactId\u003e \u003cversion\u003e1.5.22\u003c/version\u003e \u003c/dependency\u003e 启动项目，再次刷新swaggerui 页面，错误解决。 原理 swagger-models 这个依赖中，IntegerProperty类中对于example做了特殊处理 public void setExample(Object example) { if (example instanceof String) { try { this.example = Integer.parseInt((String)example); } catch (NumberFormatException var3) { //主要是这里的处理起了作用，吞了异常，直接把空值赋值给了example this.example = example; } } else { this.example = example; } } ","date":"2022-11-03","objectID":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/:2:0","tags":["SpringBoot"],"title":"“一个swraggerui的类型转换的错误\"","uri":"/%E4%B8%80%E4%B8%AAswraggerui%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%94%99%E8%AF%AF/"},{"categories":["sol"],"content":"亲测可用的snippet","date":"2022-10-09","objectID":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","tags":["Apache Utils"],"title":"使用Apache Http Client上传文件","uri":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"本文实现的是将一个文件从web页面上传至服务端，再从服务端使用Apache httpclient上传到另外一个第三方服务的功能。代码片段是验证通过的使用Apache httpclient上传到另外一个第三方服务完整代码。 ","date":"2022-10-09","objectID":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:0:0","tags":["Apache Utils"],"title":"使用Apache Http Client上传文件","uri":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"Maven dependency \u003cdependency\u003e \u003cgroupId\u003eorg.apache.httpcomponents\u003c/groupId\u003e \u003cartifactId\u003ehttpclient\u003c/artifactId\u003e \u003cversion\u003e4.5.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.httpcomponents\u003c/groupId\u003e \u003cartifactId\u003ehttpmime\u003c/artifactId\u003e \u003cversion\u003e4.5.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-10-09","objectID":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:1:0","tags":["Apache Utils"],"title":"使用Apache Http Client上传文件","uri":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"Snippet private String uploadToEkuiper(MultipartFile f){ CloseableHttpClient httpClient = null; CloseableHttpResponse response = null; try{ httpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(ekuiperEdgeUploadUrl); httpPost.setConfig(RequestConfig.custom().setConnectTimeout(1000).build()); byte [] fileBytes = f.getBytes(); ByteArrayBody bab = new ByteArrayBody(fileBytes,f.getOriginalFilename()); HttpEntity reqEntity = MultipartEntityBuilder.create() // 相当于\u003cinput type=\"file\" name=\"file\"/\u003e .addPart(\"uploadFile\", bab) .build(); httpPost.setEntity(reqEntity); //发起请求 response = httpClient.execute(httpPost); //获取响应对象 HttpEntity resEntity = response.getEntity(); if(resEntity != null){ return EntityUtils.toString(resEntity, Charset.forName(\"UTF-8\")); } }catch (Exception e){ e.printStackTrace(); }finally { try { if(response != null){ response.close(); } } catch (IOException e) { e.printStackTrace(); } try { if(httpClient != null){ httpClient.close(); } } catch (IOException e) { e.printStackTrace(); } } return null; } ","date":"2022-10-09","objectID":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:2:0","tags":["Apache Utils"],"title":"使用Apache Http Client上传文件","uri":"/%E4%BD%BF%E7%94%A8apache-http-client-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["git"],"content":"常见问题及解决方案","date":"2022-10-09","objectID":"/qa/","tags":["git"],"title":"GIT QA","uri":"/qa/"},{"categories":["git"],"content":"GIT是我目前最常用的版本管理工具，使用过程中还是会遇到一些小问题，这些问题都是因为配置不当等导致。记录下来，释放大脑内存。 fatal: unable to access ‘xxx’: OpenSSL SSL_read: Connection was reset, errno 10054 SOL: git config –global http.sslVerify “false” ","date":"2022-10-09","objectID":"/qa/:0:0","tags":["git"],"title":"GIT QA","uri":"/qa/"},{"categories":["git"],"content":"常见问题及解决方案","date":"2022-10-09","objectID":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/","tags":["git"],"title":"通过SSH的方式克隆github中的仓库","uri":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/"},{"categories":["git"],"content":"在macOS上我想克隆自己的github中的仓库，刚开始使用的是https的方式在本地执行clone命令，发现输入用户密码后，一直报一个403的错误。 换成SSH的方式就没有这个问题，但需要提前做一些配置，主要步骤如下： ","date":"2022-10-09","objectID":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/:0:0","tags":["git"],"title":"通过SSH的方式克隆github中的仓库","uri":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/"},{"categories":["git"],"content":"步骤1 本地生成SSH key ssh-keygen -t rsa -C 'youmail' 三次回车 查看复制key cat ～/.ssh/id_isa.pub 从ssh-rsa字符开始复制，到邮箱地址字符结束 ","date":"2022-10-09","objectID":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/:1:0","tags":["git"],"title":"通过SSH的方式克隆github中的仓库","uri":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/"},{"categories":["git"],"content":"步骤2 在github中创建sshkey ，并将上面本地创建的key复制到github的配置中 ","date":"2022-10-09","objectID":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/:2:0","tags":["git"],"title":"通过SSH的方式克隆github中的仓库","uri":"/git-ssh%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%8B%E9%9A%86github%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93/"},{"categories":["sol"],"content":"工作记录，使用爱组搭","date":"2022-09-28","objectID":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","tags":["aliyunOSS"],"title":"使用爱组搭实现阿里云OSS上传文件服务","uri":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"编程的过程中，如果有好的轮子，我会优先考虑使用，其次是自己从0-1去实现。这次项目中有个需求是通过前端上传文件到阿里云对象存储中供后续逻辑使用。 系统的后端框架用的微服务，文件服务中已经有一部分上传功能了，实现了文件上传到服务所在的机器磁盘，不支持上传对象存储。看到这个需求时我想到了爱组搭。爱组搭是提供SpringBoot第三方组件地代码平台，它的初衷是开发者可以使用它进行低代码甚至无代码构建自己的应用。目前来看的话，只能做到低代码。 这是爱组搭官网：http://doc.aizuda.com/ 言归正传，本次解决对象存储的需求我用的是爱组搭的OSS文件存储组件。主要步骤就是引入依赖和实现接口逻辑。 ","date":"2022-09-28","objectID":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:0:0","tags":["aliyunOSS"],"title":"使用爱组搭实现阿里云OSS上传文件服务","uri":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"引入依赖 \u003c!--爱组搭对象存储组件--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aizuda\u003c/groupId\u003e \u003cartifactId\u003eaizuda-oss\u003c/artifactId\u003e \u003cversion\u003e1.0.4\u003c/version\u003e \u003c/dependency\u003e \u003c!--阿里云对象存SDK--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun.oss\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-oss\u003c/artifactId\u003e \u003cversion\u003e3.15.0\u003c/version\u003e \u003c/dependency\u003e 爱组搭起到的作用是对阿里云的SDK进行了再封装，简化开发。如果只引入爱组搭对象存储组件服务无法启动。 ","date":"2022-09-28","objectID":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:1:0","tags":["aliyunOSS"],"title":"使用爱组搭实现阿里云OSS上传文件服务","uri":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"基础配置 配置信息直接写到注册中心nacos配置文件中即可 # 配置存储平台 ，为默认存储平台 aizuda: oss: aliyun-oss: platform: aliyun endpoint: xxx accessKey: xxx secretKey: xxx bucketName: xxx fileName: xxx/ ","date":"2022-09-28","objectID":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:2:0","tags":["aliyunOSS"],"title":"使用爱组搭实现阿里云OSS上传文件服务","uri":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"Bean方式注入 Configuration public class OssConfig { @Value(\"${aizuda.oss.aliyun-oss.end-point}\") private String endpoint; @Value(\"${aizuda.oss.aliyun-oss.accessKey}\") private String accessKey; @Value(\"${aizuda.oss.aliyun-oss.secretKey}\") private String secretKey; @Value(\"${aizuda.oss.aliyun-oss.bucketName}\") private String bucketName; @Bean public IFileStorage aliyun() { // 注入一个自定义存储平台 OssProperty ossProperty = new OssProperty(); ossProperty.setPlatform(StoragePlatform.aliyun); ossProperty.setBucketName(bucketName); ossProperty.setEndpoint(endpoint); ossProperty.setAccessKey(accessKey); ossProperty.setSecretKey(secretKey); return new AliyunOss(ossProperty); } } ","date":"2022-09-28","objectID":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:3:0","tags":["aliyunOSS"],"title":"使用爱组搭实现阿里云OSS上传文件服务","uri":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["sol"],"content":"接口实现 @Slf4j @Service(value = \"aliyunOssService\") public class AliyunOssFileInfoServiceImpl implements ISysFileInfoService { @Reference private IFileStorage fileStorage; @Value(\"${aizuda.oss.aliyun-oss.fileName}\") private String fileName; @Value(\"${aizuda.oss.aliyun-oss.end-point}\") private String endpoint; @Value(\"${aizuda.oss.aliyun-oss.bucketName}\") private String bucketName; @Override public void upload(MultipartFile[] files, String businessType) { if (files == null) { return new ArrayList\u003c\u003e(); } Arrays.asList(files).stream().map(file -\u003e aliyunUpload(file))).collect(Collectors.toList()); } private String aliyunUpload(MultipartFile f){ ByteArrayInputStream os = null; OssResult ossResult = null; AtomicReference\u003cString\u003e finalURL = new AtomicReference\u003c\u003e(); try{ String objectName = fileName+\"module/Custom/\"+f.getOriginalFilename(); byte [] fileBytes = f.getBytes(); os = new ByteArrayInputStream(fileBytes); //上传 OSS.fileStorage(\"aliyun\").upload(os, f.getOriginalFilename(),objectName); finalURL.set(String.format(\"https://%s.%s/%s\", bucketName,endpoint, objectName)); return finalURL.get(); }catch (Exception e){ } } } Tips : 接口实现是主要逻辑，其他无关代码都已经做了删除。 finalURL.set(String.format(“https://%s.%s/%s”, bucketName,endpoint, objectName)); 这行代码是为了解决组件提供的预览连接失效问题，此处需要手动拼接，供后续逻辑使用。使用这个连接的前提是阿里云OSS中药对bucket权限设置为公开读。 ","date":"2022-09-28","objectID":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:4:0","tags":["aliyunOSS"],"title":"使用爱组搭实现阿里云OSS上传文件服务","uri":"/%E4%BD%BF%E7%94%A8%E7%88%B1%E7%BB%84%E6%90%AD%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["design-pattern"],"content":"极客时间|《设计模式之美》专栏学习笔记","date":"2022-09-26","objectID":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/","tags":["design-pattern"],"title":"让你最快速地改善代码质量的20条编程规范","uri":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["design-pattern"],"content":"重复的事儿做久了，我就会让自己停下来，学习一下，只有站在巨人的肩膀上，才能省点劲儿。而不是一味地说，我以前做过xxx,因为以前的经验也可能是错的。 这一篇是小争哥（前google工程师）在极客时间专栏《设计模式之美》专栏中根据他的工作经验给出的20条编程规范，整理出来自检。 命名与注释（Naming and Comments） 完事开头难，做项目比较难的是起名字，项目名、类名、函数名、变量名、接口名都是我们平时开发时要考虑如何定义的。命名的好坏决定着代码的可读性。 ","date":"2022-09-26","objectID":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:0:0","tags":["design-pattern"],"title":"让你最快速地改善代码质量的20条编程规范","uri":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["design-pattern"],"content":"1、命名多长合适？ 在足够表达意图的情况下，命名越短越好；对于一些默认，大家比较熟悉的词，推荐使用缩写。比如 sec 表示second、str表示string、num表示number。除此之外，对于作用域比较小的变量，我们可以使用想对短的命名；对于类名这种作用域比较打的，更推荐使用长命名。 命名的原则就是准确表达意图。命名时，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否够直观。 ","date":"2022-09-26","objectID":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:1:0","tags":["design-pattern"],"title":"让你最快速地改善代码质量的20条编程规范","uri":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["design-pattern"],"content":"2、利用上下文简化命名 利用对象上下文可简化为 public class User { private String userName; private String userPassword; private String userAvatarUrl; //... } //简化为 public class User { private String name; private String password; private String avatarUrl; //... } 利用函数上下文简化命名 public void uploadUserAvatarImageToAliyun(String userAvatarImageUri); //简化为 public void uploadUserAvatarImageToAliyun(String imageUri); ","date":"2022-09-26","objectID":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:2:0","tags":["design-pattern"],"title":"让你最快速地改善代码质量的20条编程规范","uri":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["design-pattern"],"content":"3、命名可读、可搜索 可读是指，不要用特别生僻、难发音的英文单词来命名；反例：plateaux、eyrie 可搜索指，通过IDEA经常用“关键词联想”的方法自动补全和搜索，例如键入“.get”希望能找到某个对象所有get开头的方法。键入Array，搜索JDK中数组相关的类，命名时需要符合项目的规范，一起用selectXXX，insertXXX等，不要自己用queryXXX,addXXX ","date":"2022-09-26","objectID":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:3:0","tags":["design-pattern"],"title":"让你最快速地改善代码质量的20条编程规范","uri":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["design-pattern"],"content":"4、接口和抽象类命名 对于接口一般有两种： 加前缀“I”，表示Interface，比如IUserservice,对应的实现类为UserService 不加前缀“I”,比如Userservice,对应实现类为UserServiceImpl 抽象类也有两种： 带Abstract 前缀,比如 AbstractConfiguration 不带Abstract 代码风格（Code Style） 编程技巧（Coding Tips）","date":"2022-09-26","objectID":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/:4:0","tags":["design-pattern"],"title":"让你最快速地改善代码质量的20条编程规范","uri":"/%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"categories":["k8s"],"content":"极客时间|罗剑锋的《Kubernetes入门实战课》学习笔记-容器化应用","date":"2022-09-19","objectID":"/k8s%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-docker/","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记02-docker","uri":"/k8s%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-docker/"},{"categories":["k8s"],"content":"什么是容器化应用 ","date":"2022-09-19","objectID":"/k8s%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-docker/:0:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记02-docker","uri":"/k8s%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-docker/"},{"categories":["k8s"],"content":"极客时间|罗剑锋的《Kubernetes入门实战课》学习笔记","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"现在 Kubernetes 已经没有了实际意义上的竞争对手，它的地位就如同 Linux 一样，成为了事实上的云原生操作系统，是构建现代应用的基石。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"Kubernetes技术栈的四个特点 技术新 领域广 实现杂 方向深 学习Kubernetes最好的方式 建立一个全局观和大局观，了解全貌，再选择自己感谢兴趣的方向去研究。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"课程选择的版本 2022年发布的Kubernetes 1.23.3 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"学习地图 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"学习环境 课程中推荐使用VirtualBox，我目前还有一台阿里云的云服务器，就不费劲本地弄虚拟机了，直接在云服务器上面开始了。 写blog笔记和实际操作练习都是在vscode中进行。操作云服务器用的是Remote-SSH插件。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"Docker 学习这门课之前，我已经有一定的docker 方面的基础了。安装docker相关的步骤直接跳过。这是我云服务器上面之前安装的docker版本信息 [root@iZ8vb53kklhrg4j6sviqtpZ ~]# docker version Client: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-208.git7d71120.el7_9.x86_64 Go version: go1.10.3 Git commit: 7d71120/1.13.1 Built: Mon Jun 7 15:36:09 2021 OS/Arch: linux/amd64 Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-208.git7d71120.el7_9.x86_64 Go version: go1.10.3 Git commit: 7d71120/1.13.1 Built: Mon Jun 7 15:36:09 2021 OS/Arch: linux/amd64 Experimental: false ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"docker 使用 docker ps 列出系统中运行的容器，与Linux中的 ps命令类似。 拉取image 拉取busybox image docker pull busybox [root@iZ8vb53kklhrg4j6sviqtpZ ~]# docker pull busybox Using default tag: latest Trying to pull repository docker.io/library/busybox ... latest: Pulling from docker.io/library/busybox 729ce43e2c91: Pull complete Digest: sha256:ad9bd57a3a57cc95515c537b89aaa69d83a6df54c4050fcf2b41ad367bec0cd5 Status: Downloaded newer image for docker.io/busybox:latest 列出本机所存储的所有镜像 docker images [root@iZ8vb53kklhrg4j6sviqtpZ ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/busybox latest 2bd29714875d 4 days ago 1.24 MB registry.cn-shenzhen.aliyuncs.com/star7th/showdoc latest ffe481c085e9 9 months ago 602 MB star7th/showdoc latest ffe481c085e9 9 months ago 602 MB docker.io/rabbitmq 3-management c91dff94df48 9 months ago 253 MB docker.io/rabbitmq 3.9-management c91dff94df48 9 months ago 253 MB docker.io/rabbitmq latest c10b0f4fd126 9 months ago 220 MB docker.io/jenkinsci/jenkins lts d7c5abfe8477 3 years ago 703 MB registry.aliyuncs.com/helowin/oracle_11g latest 3fa112fd3642 6 years ago 6.85 GB 通过 echo输出 hello world [root@iZ8vb53kklhrg4j6sviqtpZ ~]# docker run busybox echo hello wrold hello wrold ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"docker 架构 上面的docker 相关的使用都是客户端中的行为，这些命令会与Docker Engine的后台服务 Docker daemon通信，客户端通过 build、pull、run等命令给Docker daemon发送请求，“大管家” Docker daemon负责从远端拉取镜像、本地存储镜像、从镜像生成容器和管理容器等功能。 C/S架构实现了功能分离，利于分布式应用，客户端与服务端进行了解耦。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"容器（Container）的本质 集装箱的作用是标准化封装各种货物，打包完成后，可以从一个地方迁移到任意其他地方；计算机世界中，容器封装的是运行中应用的进程，它也会把进程与外部世界隔离开，让进程与外部系统互不影响。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"通过拉取镜像Alpine练习 拉取镜像 docker pull alpine 运行 docker run -it alpine sh tips: -it参数可以离开宿主机，进入容器内部 在容器内部，我们执行cat /etc/os-release命令可以看到系统信息已经变成了Alpine Linux v3.16 / # cat /etc/os-release NAME=\"Alpine Linux\" ID=alpine VERSION_ID=3.16.2 PRETTY_NAME=\"Alpine Linux v3.16\" HOME_URL=\"https://alpinelinux.org/\" BUG_REPORT_URL=\"https://gitlab.alpinelinux.org/alpine/aports/-/issues\" 容器就是一个特殊的隔离环境，它能够让进程只看到这个环境中的有限信息，不能对外界环境施加影响。通过容器技术，我们可以让程序运行在一个有严密防护的沙盒（sandbox）环境内。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"容器与虚拟机的异同 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"共同点 容器和虚拟机的目的都是为了隔离资源，保证系统安全，提高资源利用率。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"区别 虚拟机 虚拟化出来的是硬件，需要装操作系统后才能运行应用，比较重。会消耗大量的CPU、内存和硬盘等系统资源。每台虚拟机之间的隔离程度非常高，互相完全无干扰。 容器 直接利用了下层计算机硬件和操作系统，运行效率非常高。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"容器的隔离机制是如何实现的 是基于Linux的 namespace、cgroup、chroot三个技术实现的。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"namespace 2002年从Linux2.4.19开始出现，可以创建独立的文件系统、主机名、进程号、网络等资源，实现了系统全局资源和进程局部资源之间的隔离。相当于给进程盖了小板房。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:1","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"cgroup Linux Control Group 是2008年从Linux2.6.24开始出现，作用是实现对进程的CPU、内存等资源的优先级和配合限制。相当于给小板房加了天花板。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["k8s"],"content":"chroot 早在1979年的UNIX V7就出现了，可以更改进程的根目录，限制访问文件系统。相当于给小板房铺了地板砖。 ","date":"2022-09-18","objectID":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:3","tags":["k8s"],"title":"Kubernetes入门实战课学习笔记01","uri":"/k8s%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["hugo"],"content":"首次使用Hugo搭建个人博客.","date":"2022-09-08","objectID":"/first-post/","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":" 搭建个人博客的初衷是想把以前零散的输出整理到一起，另外一个重要的原因是有很多想学、想做的事儿，当我开始做这些事儿后，过程中需要沉淀，无论是问题也好，成果也好，记录下来。 我也有其他写作平台的账号，为什么还要自己搭建一个？ 就是想尝试一下，哈哈哈。 ","date":"2022-09-08","objectID":"/first-post/:0:0","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":"安装Hugo 刚开始以为hugo需要通过服务器环境安装，我尝试用自己的阿里云ECS服务器安装，找的教程中都是说要先安装Homebrew,于是，我就被带到了坑里面，费了很大劲安装Homebrew,安装时遇到问题，需要升级服务器的其他软件，升级完了又执行安装Homebrew脚本，又识别不了新版本，于是，本次的行动卒。 打开Hugo官方github账号后发现，有windows环境的安装包，欣喜过望。开始第二次行动。 这是官方仓库：https://github.com/gohugoio/hugo/releases,我的电脑系统环境是 windows 11家庭中文版 64位操作系统，下载了hugo_extended_0.102.3_Windows-64bit.zip 安装包。 解压后，如下图所示： 配置环境变量： 查看hugo版本 hugo version 到此为止，hugo就在windows上面搭建好了 ","date":"2022-09-08","objectID":"/first-post/:1:0","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":"项目创建 $ hugo new site /path/to/site 执行完命令后，生成项目结构如下： 至此，通过hugo脚手架创建好了博客的初始项目。接下来我们需要挑选自己喜欢的主题，做相关的设置，部署运行啦。 ","date":"2022-09-08","objectID":"/first-post/:2:0","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":"主题选择 https://hugothemesfree.com/ 站点中提供了大量主题供我们选择。我选的是LoveIt这个主题。 选好主题后，进入主题github仓库，克隆到上面搭建好项目的themes目录中。 cd themes git clone https://github.com/xxx.git 主题clone到本地后，可以在主题目录中的exampleSite下找到 config.toml这个配置文件，拷贝替换项目根目录下的config.toml（非首次换皮肤时，记得备份，不过用git做版本管理，就不需要啦，历史版本都能找回）。 这个配置文件是站点的设置文件，示例站点中的配置很全面了，注释也很清晰。对于首次使用者而言，需要配置以下内容： 站点的header配置 包括站点名称、菜单栏配置等。 个人头像配置 社交账号 搜索 文章页的共通设置 站点的footer配置 设置项目很多，第一次不必一下子配置好，先试着创建自己的第一篇博文，设置项可以后面慢慢研究。第一篇博文的内容可以参考exampleSite目录content中的示例。配置项很全，看一眼应该知道每个项目干啥用的。 ","date":"2022-09-08","objectID":"/first-post/:3:0","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":"github action + page 部署 需要在自己的github中创建两个仓库，一个用来管理站点源码，另外一个用来管理构建后的静态站点。 创建仓库过程略过了。要特别说明的一点是，部署静态站点的仓库名称命名是your githubname.github.io 这样的格式。举个例子，我自己的名称是qfxiongbin.github.io。 源码仓库中，需要设置action 脚本，每次本地推送时，会触发 action的 workflow,对增量内容进行构建，构建成功后，推送到your githubname.github.io仓库中，这个仓库中接收到推送内容后会触发gitpage action,大概过个几十秒，就会部署好，刷新页面就能看到最新的内容。 ","date":"2022-09-08","objectID":"/first-post/:4:0","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":"Github action 配置 # This is a basic workflow to help you get started with Actions name: CI # Controls when the action will run. on: # Triggers the workflow on push or pull request events but only for the master branch push: branches: [main] pull_request: branches: [main] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \"build\" build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 with: submodules: false # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Hugo setup # You may pin to the exact commit or the version. # uses: peaceiris/actions-hugo@2e89aa66d0093e4cd14751b3028fc1a179452c2e uses: peaceiris/actions-hugo@v2.4.13 with: # The Hugo version to download (if necessary) and use. Example: 0.58.2 hugo-version: latest # optional, default is latest # Download (if necessary) and use Hugo extended version. Example: true extended: false # optional, default is false - name: Build run: hugo - name: Pushes to another repository uses: cpina/github-action-push-to-another-repository@main env: API_TOKEN_GITHUB: XXXXXX with: source-directory: \"public\" destination-github-username: \"qfxiongbin\" destination-repository-name: \"qfxiongbin.github.io\" user-email: qfxiongbin@163.com ","date":"2022-09-08","objectID":"/first-post/:5:0","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":"脚本说明 上面脚本中，最后三行需要配置成自己的，destination-github-username 、 destination-repository-name(这个需要配置构建后的静态站点仓库名)、user-email。 API_TOKEN_GITHUB ：https://github.com/settings/profile，Settings/Developer settings 下Personal access tokens下创建。 创建完成后，同时需要添加到your githubname.github.io /settings/secrets/actions中，配置的Secret name 为API_TOKEN_GITHUB。 ","date":"2022-09-08","objectID":"/first-post/:5:1","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"},{"categories":["hugo"],"content":"参考资料 https://ibrights.github.io/post/blog20210527/ ","date":"2022-09-08","objectID":"/first-post/:6:0","tags":["hugo","LoveIt"],"title":"主题文档 - 第一次使用Hugo搭建个人博客","uri":"/first-post/"}]